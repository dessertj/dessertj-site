== Tutorial

This tutorial not only guides you step by step to the _dessert_ features
but also it's a guideline for applying _dessert_.
Following these steps any you'll get the most benefit for your project.
To perform this tutorial, you need any Java project (any other JVM language,
like Kotlin, Scala, Groovy, etc. will do, too).
Before you start the tutorial make sure the _dessert-core_ dependency has
been added to your project, and you are able to run dessert tests as described
in the <<getting_started>> started section.

For the solutions to this tutorial see
https://github.com/hajo70/dessert-site/blob/main/dessert-sample/src/test/java/de/spricom/dessert/tutorial/DessertTutorialTest.java[DessertTutorialTest.java].
Some more advanced examples can be found in the
https://github.com/hajo70/dessert-tests/tree/master/dessert-tests-jdeps/src/test/java/de/spricom/dessert/tutorial[tutorial] package of the
https://github.com/hajo70/dessert-tests/tree/master/dessert-tests-jdeps[dessert-tests-jdeps] project.

=== Detect usage of internal APIs

Internal APIs are subject to change without notice. Using internal APIs
may cause trouble when you update a dependency. The signature of the internal
API may have changed, it may have disappeared entirely, or it may behave
differently in some corner cases. Thus, your code should not rely on any
internal API. To ensure this, write a test that detects the usage of
JDK's internal API (packages `com.sun..*` or `sun..*`) or any other internal
API from some external library (any `..internal..*` package).

=== Detect duplicates

Each JAR has its own directory structure, thus a class with the same fully qualified name
may appear in more than one JAR. The `ClassLoader` always uses the first matching class
on the classpath, but the order of the JARs on the classpath may vary on different systems.
If there are different implementations for one of the duplicates that is actually used,
some systems may fail. Such errors are hard to track down. Thus, write a test
that makes sure, there are no duplicates on the classpath. See the <<Duplicates>>
section on how to do this. If you have duplicates write
some code that helps you to track down the problem (i.e list the classes and jars involved).

NOTE: Many JARs contain a `module-info` class in their root package. Make sure to ignore
this class when checking for duplicates.

Often you cannot prevent all duplicates, but at least you should have test that informs
you if there are additional duplicates.

=== Detect cycles

The problem with a cycle is, it does not have a beginning nor does it have an end. Thus, if you
pick out any class involved in a dependency cycle you cannot use it without all other classes involved
in that cycle. This is not a problem for small cycles of closely related classes, but it's a
nightmare if you have to change a software with big intertwined cycles.

Dessert can detected cycles between any set of slices (remember: a `Clazz` is a `Slice`, too).
To start with, make sure, your software does not have any package-cycles.
See the <<Cycle detection>> section on how to do this.

=== Investigate your project

If you have any cycles in your software, you might want to find out, which classes cause that
cycle. Or you may have other questions on your software, for which the search facilities of
your IDE are not sufficient. The `slice` method in combination with <<Predicates>> lets you
filter your classes by almost any condition.

If you have a package cycle, write some code that tells you exactly which classes with two
packages involved in the cycle cause that cycle. Alternatively find out, which classes
of your project use _java.io_.

=== Simulate refactorings

Often a package cycle can simply be resolved by moving a class from on package to another,
but actually move a class may require many changes and introduce new cycles. Thus, it would
be very useful if one could find out the effects of moving a classes without actually
doing it. With _dessert_ you can use the `Slice` methods `minus` and `plus` to simulate
the removal of a `Clazz` from one slice and the addition to another.

Simulate the introduction of a new cycle by creating new slices from existing package slices.
You need at least one class cycle to do this. After you have created your simulated cycle,
make sure _dessert_ detects it.

=== Check your layers

Each nontrivial software product is built a from layers. In a classical software product you have
persistence, business logic a presentation layers. Modern designs are base on the
https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)[hexagonal architecture], also
called _ports and adapters architecture_. But these are still layered architectures with the
business logic at the bottom, now.

The architecture may be strict where one layer can only access the layer below. This is typically
the case in network protokoll implementations similar to the
https://en.wikipedia.org/wiki/OSI_model[OSI model]. In most applications the architecture
is relaxed, hence one layer can access all layers below.

A common property of the classes within one layer are there external dependencies. Thus, classes
in the presentation layer should not have dependencies persistence libraries like hibernate
and classes in the presistence layer should not have dependencies to presentation libraries like
JavaFX or Vaadin.

Now it's time to define the layers of your project. Define a slice for each layer. You may want
to use the `Slice` method `named` to assign it a name. Then use <<Architecture verification>>
to ensure your code complies with your architecture. Additionally, make sure none of your layers
has any external dependencies it should not.

=== Modularize your project

Layers are the first course subdivision of your project. Typically, your software is made up
form smaller parts by cutting down the layers to vertical slices. Each vertical slice
is tied to one domain and has certain dependencies to other parts of the of software or
to external libraries. It's good practice to explicitly name the dependencies of each
such part.

Start from the layers defined in the previous exercise and use the `slice` method to
cut them down into vertical slices. The make sure each such slice uses only the dependencies
it is allowed to, by using the `usesOnly` assertion. You might want to group your
external dependencies into corresponding slices, to do this.