:sample-dir: C:\Code\git\dessert\dessert-site\dessert-sample

== Practical Guide

=== Detecting unwanted dependencies

Developers tend to use everything, simply because it's there, and it looks it might be useful to accomplish
some task. Thus, anything which happens to be available on the class-path can be used for any purpose
in any place. If the software is working and the customers are happy, so what is the problem?
Well, some reasons for more restrictions might be:

- Internal APIs are subject to change without notice. Using internal APIs
may cause trouble when a dependency is updated.
- If you know that some library or API will be replaced by something else, or you
want to get rid of some dependency then you surely don't want that new code
uses that library.
- If you have a big monolith and want to break it down into smaller modules,
then you must reduce the dependencies that hinder you and prevent developers
to introduce additional obstacles.
- You might want to enforce a clean architecture where certain packages or
classes following some naming convention have certain responsibilities.
For example your JPA persistence layer should not use JDBC directly
or your DTOs should not access the file system.
- You want to make sure, some critical code does not use anything that
may cause security vulnerabilities.

Detecting unwanted dependencies using _dessert_ is as simple as:

[source, xml, indent=0]
----
include::{sample-dir}/src/test/java/de/spricom/dessert/guide/DetectingUnwantedDependenciesTest.java[tags=doesNotUse]
----

Every developer should be able to read and understand this.
Because it's within a unit-test it is checked during each CI build,
and it can't be ignored.

The _something_ and the _unwanted_ each are a `Slice`. In _dessert_ almost
everything is a `Slice` and you have many ways to tell what's in a
certain slice.

The starting-point for each `Slice` is the `Classpath`:

[source, xml, indent=0]
----
include::{sample-dir}/src/test/java/de/spricom/dessert/guide/DetectingUnwantedDependenciesTest.java[tags=cp]
----

NOTE: The `Classpath` is a `Slice`, too.

The _something_ is a part of your handwritten code:

[source, xml, indent=0]
----
include::{sample-dir}/src/test/java/de/spricom/dessert/guide/DetectingUnwantedDependenciesTest.java[tags=slices]
----

The _unwanted_ might be something like:

[source, xml, indent=0]
----
include::{sample-dir}/src/test/java/de/spricom/dessert/guide/DetectingUnwantedDependenciesTest.java[tags=unwanted]
----

The _something_ and the _unwanted_ examples all specify a 'Slice'. Each of them
can be use in the `assertThatSlice` or in the `doesNotUse` part of the assertion.

=== Detect duplicates

Each JAR has its own directory structure, thus a class with the same fully qualified name
may appear in more than one JAR. The `ClassLoader` always uses the first matching class
on the classpath, but the order of the JARs on the classpath may vary on different systems.
If there are different implementations for one of the duplicates that is actually used,
some systems may fail. Such errors are hard to track down. Thus, write a test
that makes sure, there are no duplicates on the classpath. See the <<Duplicates>>
section on how to do this. If you have duplicates write
some code that helps you to track down the problem (i.e list the classes and jars involved).

NOTE: Many JARs contain a `module-info` class in their root package. Make sure to ignore
this class when checking for duplicates.

Often you cannot prevent all duplicates, but at least you should have a test that informs
you if there are additional duplicates.

=== Detect cycles

The problem with a cycle is, it does not have a beginning nor does it have an end. Thus, if you
pick out any class involved in a dependency cycle you cannot use it without all other classes involved
in that cycle. This is not a problem for small cycles of closely related classes, but it's a
nightmare if you have to change a software with big intertwined cycles.

Dessert can detected cycles between any set of slices (remember: a `Clazz` is a `Slice`, too).
To start with, make sure, your software does not have any package-cycles.
See the <<Cycle detection>> section on how to do this.

=== Investigate your project

If you have any cycles in your software, you might want to find out, which classes cause that
cycle. Or you may have other questions on your software, for which the search facilities of
your IDE are not sufficient. The `slice` method in combination with <<Predicates>> lets you
filter your classes by almost any condition.

If you have a package cycle, write some code that tells you exactly which classes from two
packages involved in the cycle cause that cycle. Alternatively find out, which classes
of your project use _java.io_.

=== Simulate refactorings

Often a package cycle can simply be resolved by moving a class from on package to another,
but actually moving a class may require many changes and introduce new cycles. Thus, it would
be very useful if one could find out the effects of moving a classes without actually
doing it. With _dessert_ you can use the `Slice` methods `minus` and `plus` to simulate
the removal of a `Clazz` from one slice and the addition to another.

Simulate the introduction of a new package-cycle by creating new slices from existing package
slices with one or more classes moved from one package to another.
After you have created your simulated cycle, make sure _dessert_ detects it.

=== Check your layers

Each nontrivial software product is composed of layers. In a classical software product you have
persistence, business logic a presentation layers. Modern designs are base on the
https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)[hexagonal architecture], also
called _ports and adapters architecture_. But these are still layered architectures with the
business logic at the bottom, now.

The architecture may be strict where one layer can only access the layer below. This is typically
the case in network protocol implementations similar to the
https://en.wikipedia.org/wiki/OSI_model[OSI model]. In most applications the architecture
is relaxed, hence one layer can access all layers below.

A common property of the classes within one layer are there external dependencies. Thus, classes
in the presentation layer should not have dependencies to persistence libraries like hibernate
and classes in the persistence layer should not have dependencies to presentation libraries like
JavaFX or Vaadin.

Now it's time to define the layers of your project. Define a slice for each layer. You may want
to use the `Slice` method `named` to assign it a name. Then use <<Architecture verification>>
to ensure your code complies with your architecture. Additionally, make sure none of your layers
has any external dependencies it should not.

=== Modularize your project

Layers are the first coarse subdivision of your project. Typically, your software is made up
form smaller parts by cutting down the layers to vertical slices. Each vertical slice
is tied to one domain and has certain dependencies to other parts of the software or
to external libraries. It's good practice to explicitly name the dependencies of each
such part.

Start from the layers defined in the previous exercise and use the `slice` method to
cut them down into vertical slices. Then make sure, each such slice uses only the dependencies
it is allowed to, by using the `usesOnly` assertion. You might want to group your
external dependencies into corresponding slices, to do this.

The slices defined in this step are the building blocks of your project. We might call some
modules, but that term is already occupied in the java world, thus I'll stay with building
block. Often you don't want to expose anything from one building block to others. You can
accomplish this by defining one or more interface slices for each build block and make sure
the depending building blocks only use the corresponding interface slice.

=== Define your custom classpath

By default, the `Classpath` is based on the path defined by the _java.class.path_ system property.
This fits most cases, but there might be circumstances where this is not suitable.
See <<Class resolving>> on how you can define your own custom classpath.
Then define a custom Classpath that contains all elements of the _java.class.path_ system property
in reverse order. Check if your tests produce the same results.